package vss

import (
	"crypto/elliptic"
	"errors"
	"fmt"
	"math/big"
)

// Share represents a secret share with an x-coordinate and corresponding
// y-coordinate, generated from a polynomial in a finite field.
type Share struct {
	X, Y *big.Int
}

// Verify checks the integrity of a share using commitments generated by the
// dealer from the original polynomial coefficients. It ensures that the
// share's y-coordinate corresponds to the polynomial evaluated at the
// x-coordinate.
//
// This function is typically executed by each participant upon receiving a
// share along with the commitments published by a dealer.
func (share *Share) Verify(curve elliptic.Curve, threshold int, commits []*ECPoint) (bool, error) {
	if commits == nil {
		return false, errors.New("commits cannot be nil")
	}
	if len(commits) != threshold {
		return false, fmt.Errorf("commits length %d does not correspond to threshold %d", len(commits), threshold)
	}

	acc := *commits[0]
	tk := big.NewInt(1)

	for k := 1; k < threshold; k++ {
		tk.Mul(tk, share.X) // Calculate t^k
		tk.Mod(tk, curve.Params().N)

		// Multiply the k-th commitment by t^k
		cktkX, cktkY := curve.ScalarMult(commits[k].X, commits[k].Y, tk.Bytes())
		acc.X, acc.Y = curve.Add(acc.X, acc.Y, cktkX, cktkY)
	}

	fiGx, fiGy := curve.ScalarBaseMult(share.Y.Bytes())
	return fiGx.Cmp(acc.X) == 0 && fiGy.Cmp(acc.Y) == 0, nil
}
