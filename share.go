package vss

import (
	"crypto/elliptic"
	"fmt"
	"math/big"
)

// Share represents a secret share with an x-coordinate and corresponding
// y-coordinate, generated from a polynomial in a finite field.
type Share struct {
	X, Y *big.Int
}

// Verify checks the integrity of a share using commitments generated by the
// dealer from the original polynomial coefficients. It ensures that the
// share's y-coordinate corresponds to the polynomial evaluated at the
// x-coordinate.
//
// This function is typically executed by each participant upon receiving a
// share along with the commitments published by a dealer.
func (share *Share) Verify(
	curve elliptic.Curve,
	threshold int,
	commits []*ECPoint,
	opts ...option,
) (bool, error) {
	withBlinding := false
	for _, op := range opts {
		op(&withBlinding)
	}

	expectedLen := threshold
	if withBlinding {
		expectedLen = 2 * threshold
	}
	if len(commits) != expectedLen {
		return false, fmt.Errorf("commits length %d does not correspond to expected length %d", len(commits), expectedLen)
	}

	acc := *commits[0]
	tk := big.NewInt(1)

	for k := 1; k < threshold; k++ {
		tk.Mul(tk, share.X) // Calculate t^k
		tk.Mod(tk, curve.Params().N)

		// Multiply the k-th commitment by t^k
		secretCommitX, secretCommitY := curve.ScalarMult(commits[k].X, commits[k].Y, tk.Bytes())
		acc.X, acc.Y = curve.Add(acc.X, acc.Y, secretCommitX, secretCommitY)

		if withBlinding {
			blindingCommitIndex := k + threshold
			blindingCommitX, blindingCommitY := curve.ScalarMult(
				commits[blindingCommitIndex].X,
				commits[blindingCommitIndex].Y,
				tk.Bytes(),
			)
			acc.X, acc.Y = curve.Add(acc.X, acc.Y, blindingCommitX, blindingCommitY)
		}
	}

	expectedX, expectedY := curve.ScalarBaseMult(share.Y.Bytes())
	return expectedX.Cmp(acc.X) == 0 && expectedY.Cmp(acc.Y) == 0, nil
}
